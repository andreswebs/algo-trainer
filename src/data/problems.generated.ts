/**
 * Generated problem data
 *
 * This file is auto-generated from src/data/problems/*.json
 * DO NOT EDIT MANUALLY - run `deno task generate-problems` to regenerate
 *
 * Generated at: 2026-01-22T00:43:28.207Z
 * Total problems: 16
 */

/**
 * Raw problem JSON data as string constants
 */
export const PROBLEM_DATA: Record<string, string> = {
  '3sum': "{\n  \"id\": \"15\",\n  \"slug\": \"3sum\",\n  \"title\": \"3Sum\",\n  \"difficulty\": \"medium\",\n  \"description\": \"Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.\\n\\nNotice that the solution set must not contain duplicate triplets.\",\n  \"examples\": [\n    {\n      \"input\": { \"nums\": [-1, 0, 1, 2, -1, -4] },\n      \"output\": [[-1, -1, 2], [-1, 0, 1]],\n      \"explanation\": \"nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0. nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0. nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0. The distinct triplets are [-1,0,1] and [-1,-1,2].\"\n    },\n    {\n      \"input\": { \"nums\": [0, 1, 1] },\n      \"output\": []\n    },\n    {\n      \"input\": { \"nums\": [0, 0, 0] },\n      \"output\": [[0, 0, 0]]\n    }\n  ],\n  \"constraints\": [\n    \"3 <= nums.length <= 3000\",\n    \"-10^5 <= nums[i] <= 10^5\"\n  ],\n  \"hints\": [\n    \"Sort the array first. This makes it easier to skip duplicates and use two pointers.\",\n    \"For each element, use two pointers to find pairs that sum to the negative of that element.\",\n    \"Skip duplicate values to avoid duplicate triplets in the result.\"\n  ],\n  \"tags\": [\"array\", \"two-pointers\", \"sorting\"],\n  \"companies\": [\"Amazon\", \"Facebook\", \"Microsoft\", \"Google\", \"Apple\"],\n  \"leetcodeUrl\": \"https://leetcode.com/problems/3sum/\",\n  \"createdAt\": \"2024-01-15T10:30:00.000Z\",\n  \"updatedAt\": \"2024-06-20T14:45:00.000Z\",\n  \"metadata\": {\n    \"source\": \"leetcode\",\n    \"sourceId\": \"15\"\n  }\n}\n",
  'add-two-numbers': "{\n  \"id\": \"2\",\n  \"slug\": \"add-two-numbers\",\n  \"title\": \"Add Two Numbers\",\n  \"difficulty\": \"medium\",\n  \"description\": \"You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\\n\\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\",\n  \"examples\": [\n    {\n      \"input\": { \"l1\": [2, 4, 3], \"l2\": [5, 6, 4] },\n      \"output\": [7, 0, 8],\n      \"explanation\": \"342 + 465 = 807.\"\n    },\n    {\n      \"input\": { \"l1\": [0], \"l2\": [0] },\n      \"output\": [0]\n    },\n    {\n      \"input\": { \"l1\": [9, 9, 9, 9, 9, 9, 9], \"l2\": [9, 9, 9, 9] },\n      \"output\": [8, 9, 9, 9, 0, 0, 0, 1]\n    }\n  ],\n  \"constraints\": [\n    \"The number of nodes in each linked list is in the range [1, 100].\",\n    \"0 <= Node.val <= 9\",\n    \"It is guaranteed that the list represents a number that does not have leading zeros.\"\n  ],\n  \"hints\": [\n    \"Traverse both lists simultaneously, adding corresponding digits.\",\n    \"Don't forget to handle the carry when the sum is >= 10.\",\n    \"What happens when the lists have different lengths? When there's a final carry?\"\n  ],\n  \"tags\": [\"linked-list\", \"math\", \"recursion\"],\n  \"companies\": [\"Amazon\", \"Microsoft\", \"Apple\", \"Facebook\", \"Google\"],\n  \"leetcodeUrl\": \"https://leetcode.com/problems/add-two-numbers/\",\n  \"createdAt\": \"2024-01-15T10:30:00.000Z\",\n  \"updatedAt\": \"2024-06-20T14:45:00.000Z\",\n  \"metadata\": {\n    \"source\": \"leetcode\",\n    \"sourceId\": \"2\"\n  }\n}\n",
  'binary-tree-level-order-traversal': "{\n  \"id\": \"102\",\n  \"slug\": \"binary-tree-level-order-traversal\",\n  \"title\": \"Binary Tree Level Order Traversal\",\n  \"difficulty\": \"medium\",\n  \"description\": \"Given the `root` of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).\",\n  \"examples\": [\n    {\n      \"input\": { \"root\": [3, 9, 20, null, null, 15, 7] },\n      \"output\": [[3], [9, 20], [15, 7]]\n    },\n    {\n      \"input\": { \"root\": [1] },\n      \"output\": [[1]]\n    },\n    {\n      \"input\": { \"root\": [] },\n      \"output\": []\n    }\n  ],\n  \"constraints\": [\n    \"The number of nodes in the tree is in the range [0, 2000].\",\n    \"-1000 <= Node.val <= 1000\"\n  ],\n  \"hints\": [\n    \"Use a queue (BFS) to process nodes level by level.\",\n    \"For each level, process all nodes currently in the queue before moving to the next level.\",\n    \"Track the number of nodes at the current level to know when a level is complete.\"\n  ],\n  \"tags\": [\"tree\", \"breadth-first-search\", \"binary-tree\"],\n  \"companies\": [\"Amazon\", \"Microsoft\", \"Facebook\", \"Apple\", \"Bloomberg\"],\n  \"leetcodeUrl\": \"https://leetcode.com/problems/binary-tree-level-order-traversal/\",\n  \"createdAt\": \"2024-01-15T10:30:00.000Z\",\n  \"updatedAt\": \"2024-06-20T14:45:00.000Z\",\n  \"metadata\": {\n    \"source\": \"leetcode\",\n    \"sourceId\": \"102\"\n  }\n}\n",
  'climbing-stairs': "{\n  \"id\": \"70\",\n  \"slug\": \"climbing-stairs\",\n  \"title\": \"Climbing Stairs\",\n  \"difficulty\": \"easy\",\n  \"description\": \"You are climbing a staircase. It takes `n` steps to reach the top.\\n\\nEach time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?\",\n  \"examples\": [\n    {\n      \"input\": { \"n\": 2 },\n      \"output\": 2,\n      \"explanation\": \"There are two ways to climb to the top: 1. 1 step + 1 step, 2. 2 steps\"\n    },\n    {\n      \"input\": { \"n\": 3 },\n      \"output\": 3,\n      \"explanation\": \"There are three ways to climb to the top: 1. 1 step + 1 step + 1 step, 2. 1 step + 2 steps, 3. 2 steps + 1 step\"\n    }\n  ],\n  \"constraints\": [\n    \"1 <= n <= 45\"\n  ],\n  \"hints\": [\n    \"To reach step i, you can either come from step i-1 or step i-2. How does this help?\",\n    \"This is essentially computing the Fibonacci sequence. Can you see why?\",\n    \"You can optimize space by only keeping track of the last two values instead of the entire array.\"\n  ],\n  \"tags\": [\"math\", \"dynamic-programming\", \"memoization\"],\n  \"companies\": [\"Amazon\", \"Apple\", \"Adobe\"],\n  \"leetcodeUrl\": \"https://leetcode.com/problems/climbing-stairs/\",\n  \"createdAt\": \"2024-01-15T10:30:00.000Z\",\n  \"updatedAt\": \"2024-06-20T14:45:00.000Z\",\n  \"metadata\": {\n    \"source\": \"leetcode\",\n    \"sourceId\": \"70\"\n  }\n}\n",
  'coin-change': "{\n  \"id\": \"322\",\n  \"slug\": \"coin-change\",\n  \"title\": \"Coin Change\",\n  \"difficulty\": \"medium\",\n  \"description\": \"You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.\\n\\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return `-1`.\\n\\nYou may assume that you have an infinite number of each kind of coin.\",\n  \"examples\": [\n    {\n      \"input\": { \"coins\": [1, 2, 5], \"amount\": 11 },\n      \"output\": 3,\n      \"explanation\": \"11 = 5 + 5 + 1\"\n    },\n    {\n      \"input\": { \"coins\": [2], \"amount\": 3 },\n      \"output\": -1\n    },\n    {\n      \"input\": { \"coins\": [1], \"amount\": 0 },\n      \"output\": 0\n    }\n  ],\n  \"constraints\": [\n    \"1 <= coins.length <= 12\",\n    \"1 <= coins[i] <= 2^31 - 1\",\n    \"0 <= amount <= 10^4\"\n  ],\n  \"hints\": [\n    \"This is a classic dynamic programming problem. Think about what subproblems you need to solve.\",\n    \"For each amount from 1 to target, compute the minimum coins needed using smaller amounts.\",\n    \"dp[i] = min(dp[i], dp[i - coin] + 1) for each coin denomination.\"\n  ],\n  \"tags\": [\"array\", \"dynamic-programming\", \"breadth-first-search\"],\n  \"companies\": [\"Amazon\", \"Microsoft\", \"Apple\", \"Goldman Sachs\"],\n  \"leetcodeUrl\": \"https://leetcode.com/problems/coin-change/\",\n  \"createdAt\": \"2024-01-15T10:30:00.000Z\",\n  \"updatedAt\": \"2024-06-20T14:45:00.000Z\",\n  \"metadata\": {\n    \"source\": \"leetcode\",\n    \"sourceId\": \"322\"\n  }\n}\n",
  'container-with-most-water': "{\n  \"id\": \"11\",\n  \"slug\": \"container-with-most-water\",\n  \"title\": \"Container With Most Water\",\n  \"difficulty\": \"medium\",\n  \"description\": \"You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `i`th line are `(i, 0)` and `(i, height[i])`.\\n\\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\\n\\nReturn the maximum amount of water a container can store.\\n\\n**Notice** that you may not slant the container.\",\n  \"examples\": [\n    {\n      \"input\": { \"height\": [1, 8, 6, 2, 5, 4, 8, 3, 7] },\n      \"output\": 49,\n      \"explanation\": \"The vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water the container can contain is 49 (between index 1 and 8).\"\n    },\n    {\n      \"input\": { \"height\": [1, 1] },\n      \"output\": 1\n    }\n  ],\n  \"constraints\": [\n    \"n == height.length\",\n    \"2 <= n <= 10^5\",\n    \"0 <= height[i] <= 10^4\"\n  ],\n  \"hints\": [\n    \"Start with the widest container (pointers at both ends) and work inward.\",\n    \"The area is limited by the shorter line. Moving the shorter line inward might find a taller one.\",\n    \"Moving the taller line inward can only decrease or maintain the area, never increase it.\"\n  ],\n  \"tags\": [\"array\", \"two-pointers\", \"greedy\"],\n  \"companies\": [\"Amazon\", \"Facebook\", \"Google\", \"Apple\", \"Bloomberg\"],\n  \"leetcodeUrl\": \"https://leetcode.com/problems/container-with-most-water/\",\n  \"createdAt\": \"2024-01-15T10:30:00.000Z\",\n  \"updatedAt\": \"2024-06-20T14:45:00.000Z\",\n  \"metadata\": {\n    \"source\": \"leetcode\",\n    \"sourceId\": \"11\"\n  }\n}\n",
  'contains-duplicate': "{\n  \"id\": \"217\",\n  \"slug\": \"contains-duplicate\",\n  \"title\": \"Contains Duplicate\",\n  \"difficulty\": \"easy\",\n  \"description\": \"Given an integer array `nums`, return `true` if any value appears **at least twice** in the array, and return `false` if every element is distinct.\",\n  \"examples\": [\n    {\n      \"input\": { \"nums\": [1, 2, 3, 1] },\n      \"output\": true\n    },\n    {\n      \"input\": { \"nums\": [1, 2, 3, 4] },\n      \"output\": false\n    },\n    {\n      \"input\": { \"nums\": [1, 1, 1, 3, 3, 4, 3, 2, 4, 2] },\n      \"output\": true\n    }\n  ],\n  \"constraints\": [\n    \"1 <= nums.length <= 10^5\",\n    \"-10^9 <= nums[i] <= 10^9\"\n  ],\n  \"hints\": [\n    \"A naive approach would be to compare every pair of elements. What's the time complexity of this?\",\n    \"Think about using a hash set to track numbers you've already seen.\",\n    \"Sorting the array first could also work - duplicates would be adjacent.\"\n  ],\n  \"tags\": [\"array\", \"hash-table\", \"sorting\"],\n  \"companies\": [\"Amazon\", \"Apple\", \"Adobe\", \"Google\"],\n  \"leetcodeUrl\": \"https://leetcode.com/problems/contains-duplicate/\",\n  \"createdAt\": \"2024-01-15T10:30:00.000Z\",\n  \"updatedAt\": \"2024-06-20T14:45:00.000Z\",\n  \"metadata\": {\n    \"source\": \"leetcode\",\n    \"sourceId\": \"217\"\n  }\n}\n",
  'longest-substring-without-repeating-characters': "{\n  \"id\": \"3\",\n  \"slug\": \"longest-substring-without-repeating-characters\",\n  \"title\": \"Longest Substring Without Repeating Characters\",\n  \"difficulty\": \"medium\",\n  \"description\": \"Given a string `s`, find the length of the **longest substring** without repeating characters.\",\n  \"examples\": [\n    {\n      \"input\": { \"s\": \"abcabcbb\" },\n      \"output\": 3,\n      \"explanation\": \"The answer is \\\"abc\\\", with the length of 3.\"\n    },\n    {\n      \"input\": { \"s\": \"bbbbb\" },\n      \"output\": 1,\n      \"explanation\": \"The answer is \\\"b\\\", with the length of 1.\"\n    },\n    {\n      \"input\": { \"s\": \"pwwkew\" },\n      \"output\": 3,\n      \"explanation\": \"The answer is \\\"wke\\\", with the length of 3. Notice that the answer must be a substring, \\\"pwke\\\" is a subsequence and not a substring.\"\n    }\n  ],\n  \"constraints\": [\n    \"0 <= s.length <= 5 * 10^4\",\n    \"s consists of English letters, digits, symbols and spaces.\"\n  ],\n  \"hints\": [\n    \"Use the sliding window technique with two pointers.\",\n    \"A hash map or set can help you track characters in the current window.\",\n    \"When you find a duplicate, shrink the window from the left until the duplicate is removed.\"\n  ],\n  \"tags\": [\"string\", \"hash-table\", \"sliding-window\"],\n  \"companies\": [\"Amazon\", \"Google\", \"Facebook\", \"Microsoft\", \"Bloomberg\"],\n  \"leetcodeUrl\": \"https://leetcode.com/problems/longest-substring-without-repeating-characters/\",\n  \"createdAt\": \"2024-01-15T10:30:00.000Z\",\n  \"updatedAt\": \"2024-06-20T14:45:00.000Z\",\n  \"metadata\": {\n    \"source\": \"leetcode\",\n    \"sourceId\": \"3\"\n  }\n}\n",
  'median-of-two-sorted-arrays': "{\n  \"id\": \"4\",\n  \"slug\": \"median-of-two-sorted-arrays\",\n  \"title\": \"Median of Two Sorted Arrays\",\n  \"difficulty\": \"hard\",\n  \"description\": \"Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return **the median** of the two sorted arrays.\\n\\nThe overall run time complexity should be `O(log (m+n))`.\",\n  \"examples\": [\n    {\n      \"input\": { \"nums1\": [1, 3], \"nums2\": [2] },\n      \"output\": 2.0,\n      \"explanation\": \"merged array = [1,2,3] and median is 2.\"\n    },\n    {\n      \"input\": { \"nums1\": [1, 2], \"nums2\": [3, 4] },\n      \"output\": 2.5,\n      \"explanation\": \"merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\"\n    }\n  ],\n  \"constraints\": [\n    \"nums1.length == m\",\n    \"nums2.length == n\",\n    \"0 <= m <= 1000\",\n    \"0 <= n <= 1000\",\n    \"1 <= m + n <= 2000\",\n    \"-10^6 <= nums1[i], nums2[i] <= 10^6\"\n  ],\n  \"hints\": [\n    \"Think about how you would partition both arrays such that elements on the left are all smaller than elements on the right.\",\n    \"Binary search on the smaller array to find the correct partition point.\",\n    \"The median can be found from the elements at the partition boundary.\"\n  ],\n  \"tags\": [\"array\", \"binary-search\", \"divide-and-conquer\"],\n  \"companies\": [\"Amazon\", \"Google\", \"Apple\", \"Microsoft\", \"Goldman Sachs\"],\n  \"leetcodeUrl\": \"https://leetcode.com/problems/median-of-two-sorted-arrays/\",\n  \"createdAt\": \"2024-01-15T10:30:00.000Z\",\n  \"updatedAt\": \"2024-06-20T14:45:00.000Z\",\n  \"metadata\": {\n    \"source\": \"leetcode\",\n    \"sourceId\": \"4\"\n  }\n}\n",
  'merge-k-sorted-lists': "{\n  \"id\": \"23\",\n  \"slug\": \"merge-k-sorted-lists\",\n  \"title\": \"Merge k Sorted Lists\",\n  \"difficulty\": \"hard\",\n  \"description\": \"You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.\\n\\nMerge all the linked-lists into one sorted linked-list and return it.\",\n  \"examples\": [\n    {\n      \"input\": { \"lists\": [[1, 4, 5], [1, 3, 4], [2, 6]] },\n      \"output\": [1, 1, 2, 3, 4, 4, 5, 6],\n      \"explanation\": \"The linked-lists are: [1->4->5, 1->3->4, 2->6]. Merging them into one sorted list: 1->1->2->3->4->4->5->6\"\n    },\n    {\n      \"input\": { \"lists\": [] },\n      \"output\": []\n    },\n    {\n      \"input\": { \"lists\": [[]] },\n      \"output\": []\n    }\n  ],\n  \"constraints\": [\n    \"k == lists.length\",\n    \"0 <= k <= 10^4\",\n    \"0 <= lists[i].length <= 500\",\n    \"-10^4 <= lists[i][j] <= 10^4\",\n    \"lists[i] is sorted in ascending order.\",\n    \"The sum of lists[i].length will not exceed 10^4.\"\n  ],\n  \"hints\": [\n    \"Consider using a min-heap (priority queue) to always get the smallest element across all lists.\",\n    \"Another approach is divide and conquer: merge pairs of lists, then merge those results.\",\n    \"You can reuse the 'merge two sorted lists' solution as a building block.\"\n  ],\n  \"tags\": [\"linked-list\", \"divide-and-conquer\", \"heap\", \"merge-sort\"],\n  \"companies\": [\"Amazon\", \"Facebook\", \"Microsoft\", \"Google\", \"Apple\"],\n  \"leetcodeUrl\": \"https://leetcode.com/problems/merge-k-sorted-lists/\",\n  \"createdAt\": \"2024-01-15T10:30:00.000Z\",\n  \"updatedAt\": \"2024-06-20T14:45:00.000Z\",\n  \"metadata\": {\n    \"source\": \"leetcode\",\n    \"sourceId\": \"23\"\n  }\n}\n",
  'merge-two-sorted-lists': "{\n  \"id\": \"21\",\n  \"slug\": \"merge-two-sorted-lists\",\n  \"title\": \"Merge Two Sorted Lists\",\n  \"difficulty\": \"easy\",\n  \"description\": \"You are given the heads of two sorted linked lists `list1` and `list2`.\\n\\nMerge the two lists into one **sorted** list. The list should be made by splicing together the nodes of the first two lists.\\n\\nReturn the head of the merged linked list.\",\n  \"examples\": [\n    {\n      \"input\": { \"list1\": [1, 2, 4], \"list2\": [1, 3, 4] },\n      \"output\": [1, 1, 2, 3, 4, 4]\n    },\n    {\n      \"input\": { \"list1\": [], \"list2\": [] },\n      \"output\": []\n    },\n    {\n      \"input\": { \"list1\": [], \"list2\": [0] },\n      \"output\": [0]\n    }\n  ],\n  \"constraints\": [\n    \"The number of nodes in both lists is in the range [0, 50].\",\n    \"-100 <= Node.val <= 100\",\n    \"Both list1 and list2 are sorted in non-decreasing order.\"\n  ],\n  \"hints\": [\n    \"Use a dummy head node to simplify the merging process.\",\n    \"Compare the current nodes of both lists and attach the smaller one to your result list.\",\n    \"Don't forget to handle the case when one list is exhausted before the other.\"\n  ],\n  \"tags\": [\"linked-list\", \"recursion\"],\n  \"companies\": [\"Amazon\", \"Microsoft\", \"Apple\", \"Facebook\"],\n  \"leetcodeUrl\": \"https://leetcode.com/problems/merge-two-sorted-lists/\",\n  \"createdAt\": \"2024-01-15T10:30:00.000Z\",\n  \"updatedAt\": \"2024-06-20T14:45:00.000Z\",\n  \"metadata\": {\n    \"source\": \"leetcode\",\n    \"sourceId\": \"21\"\n  }\n}\n",
  'palindrome-number': "{\n  \"id\": \"9\",\n  \"slug\": \"palindrome-number\",\n  \"title\": \"Palindrome Number\",\n  \"difficulty\": \"easy\",\n  \"description\": \"Given an integer `x`, return `true` if `x` is a palindrome, and `false` otherwise.\\n\\nAn integer is a palindrome when it reads the same backward as forward.\\n\\n- For example, `121` is a palindrome while `123` is not.\",\n  \"examples\": [\n    {\n      \"input\": { \"x\": 121 },\n      \"output\": true,\n      \"explanation\": \"121 reads as 121 from left to right and from right to left.\"\n    },\n    {\n      \"input\": { \"x\": -121 },\n      \"output\": false,\n      \"explanation\": \"From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\"\n    },\n    {\n      \"input\": { \"x\": 10 },\n      \"output\": false,\n      \"explanation\": \"Reads 01 from right to left. Therefore it is not a palindrome.\"\n    }\n  ],\n  \"constraints\": [\n    \"-2^31 <= x <= 2^31 - 1\"\n  ],\n  \"hints\": [\n    \"Negative numbers are not palindromes. Think about why.\",\n    \"Could you solve it without converting the integer to a string?\",\n    \"Try reversing only half of the number. How would you know when you've reached the middle?\"\n  ],\n  \"tags\": [\"math\"],\n  \"companies\": [\"Amazon\", \"Adobe\", \"Yahoo\"],\n  \"leetcodeUrl\": \"https://leetcode.com/problems/palindrome-number/\",\n  \"createdAt\": \"2024-01-15T10:30:00.000Z\",\n  \"updatedAt\": \"2024-06-20T14:45:00.000Z\",\n  \"metadata\": {\n    \"source\": \"leetcode\",\n    \"sourceId\": \"9\"\n  }\n}\n",
  'reverse-string': "{\n  \"id\": \"344\",\n  \"slug\": \"reverse-string\",\n  \"title\": \"Reverse String\",\n  \"difficulty\": \"easy\",\n  \"description\": \"Write a function that reverses a string. The input string is given as an array of characters `s`.\\n\\nYou must do this by modifying the input array in-place with O(1) extra memory.\",\n  \"examples\": [\n    {\n      \"input\": { \"s\": [\"h\", \"e\", \"l\", \"l\", \"o\"] },\n      \"output\": [\"o\", \"l\", \"l\", \"e\", \"h\"]\n    },\n    {\n      \"input\": { \"s\": [\"H\", \"a\", \"n\", \"n\", \"a\", \"h\"] },\n      \"output\": [\"h\", \"a\", \"n\", \"n\", \"a\", \"H\"]\n    }\n  ],\n  \"constraints\": [\n    \"1 <= s.length <= 10^5\",\n    \"s[i] is a printable ASCII character.\"\n  ],\n  \"hints\": [\n    \"Think about using two pointers - one at the start and one at the end.\",\n    \"Swap the characters at the two pointers, then move them towards each other.\",\n    \"Continue until the pointers meet or cross.\"\n  ],\n  \"tags\": [\"string\", \"two-pointers\"],\n  \"companies\": [\"Amazon\", \"Apple\", \"Microsoft\"],\n  \"leetcodeUrl\": \"https://leetcode.com/problems/reverse-string/\",\n  \"createdAt\": \"2024-01-15T10:30:00.000Z\",\n  \"updatedAt\": \"2024-06-20T14:45:00.000Z\",\n  \"metadata\": {\n    \"source\": \"leetcode\",\n    \"sourceId\": \"344\"\n  }\n}\n",
  'trapping-rain-water': "{\n  \"id\": \"42\",\n  \"slug\": \"trapping-rain-water\",\n  \"title\": \"Trapping Rain Water\",\n  \"difficulty\": \"hard\",\n  \"description\": \"Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.\",\n  \"examples\": [\n    {\n      \"input\": { \"height\": [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1] },\n      \"output\": 6,\n      \"explanation\": \"The elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\"\n    },\n    {\n      \"input\": { \"height\": [4, 2, 0, 3, 2, 5] },\n      \"output\": 9\n    }\n  ],\n  \"constraints\": [\n    \"n == height.length\",\n    \"1 <= n <= 2 * 10^4\",\n    \"0 <= height[i] <= 10^5\"\n  ],\n  \"hints\": [\n    \"Water at any position is determined by the minimum of the maximum heights on both sides.\",\n    \"You can precompute the maximum height to the left and right of each position.\",\n    \"A two-pointer approach can solve this in O(1) space by processing from both ends.\"\n  ],\n  \"tags\": [\"array\", \"two-pointers\", \"dynamic-programming\", \"stack\", \"monotonic-stack\"],\n  \"companies\": [\"Amazon\", \"Google\", \"Facebook\", \"Microsoft\", \"Goldman Sachs\"],\n  \"leetcodeUrl\": \"https://leetcode.com/problems/trapping-rain-water/\",\n  \"createdAt\": \"2024-01-15T10:30:00.000Z\",\n  \"updatedAt\": \"2024-06-20T14:45:00.000Z\",\n  \"metadata\": {\n    \"source\": \"leetcode\",\n    \"sourceId\": \"42\"\n  }\n}\n",
  'two-sum': "{\n  \"id\": \"1\",\n  \"slug\": \"two-sum\",\n  \"title\": \"Two Sum\",\n  \"difficulty\": \"easy\",\n  \"description\": \"Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.\\n\\nYou may assume that each input would have **exactly one solution**, and you may not use the same element twice.\\n\\nYou can return the answer in any order.\",\n  \"examples\": [\n    {\n      \"input\": { \"nums\": [2, 7, 11, 15], \"target\": 9 },\n      \"output\": [0, 1],\n      \"explanation\": \"Because nums[0] + nums[1] == 9, we return [0, 1].\"\n    },\n    {\n      \"input\": { \"nums\": [3, 2, 4], \"target\": 6 },\n      \"output\": [1, 2]\n    },\n    {\n      \"input\": { \"nums\": [3, 3], \"target\": 6 },\n      \"output\": [0, 1]\n    }\n  ],\n  \"constraints\": [\n    \"2 <= nums.length <= 10^4\",\n    \"-10^9 <= nums[i] <= 10^9\",\n    \"-10^9 <= target <= 10^9\",\n    \"Only one valid answer exists.\"\n  ],\n  \"hints\": [\n    \"A brute force approach would check every pair of numbers. Can you do better?\",\n    \"Think about what information you need to store as you iterate through the array.\",\n    \"Use a hash map to store numbers you've seen and their indices.\"\n  ],\n  \"tags\": [\"array\", \"hash-table\"],\n  \"companies\": [\"Amazon\", \"Google\", \"Facebook\", \"Microsoft\", \"Apple\"],\n  \"leetcodeUrl\": \"https://leetcode.com/problems/two-sum/\",\n  \"createdAt\": \"2024-01-15T10:30:00.000Z\",\n  \"updatedAt\": \"2024-06-20T14:45:00.000Z\",\n  \"metadata\": {\n    \"source\": \"leetcode\",\n    \"sourceId\": \"1\"\n  }\n}\n",
  'valid-parentheses': "{\n  \"id\": \"20\",\n  \"slug\": \"valid-parentheses\",\n  \"title\": \"Valid Parentheses\",\n  \"difficulty\": \"easy\",\n  \"description\": \"Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.\\n\\nAn input string is valid if:\\n\\n1. Open brackets must be closed by the same type of brackets.\\n2. Open brackets must be closed in the correct order.\\n3. Every close bracket has a corresponding open bracket of the same type.\",\n  \"examples\": [\n    {\n      \"input\": { \"s\": \"()\" },\n      \"output\": true\n    },\n    {\n      \"input\": { \"s\": \"()[]{}\" },\n      \"output\": true\n    },\n    {\n      \"input\": { \"s\": \"(]\" },\n      \"output\": false\n    },\n    {\n      \"input\": { \"s\": \"([)]\" },\n      \"output\": false\n    },\n    {\n      \"input\": { \"s\": \"{[]}\" },\n      \"output\": true\n    }\n  ],\n  \"constraints\": [\n    \"1 <= s.length <= 10^4\",\n    \"s consists of parentheses only '()[]{}'.\"\n  ],\n  \"hints\": [\n    \"Think about using a stack data structure. What should you do when you encounter an opening bracket vs a closing bracket?\",\n    \"When you see an opening bracket, push it onto the stack. When you see a closing bracket, check if it matches the top of the stack.\",\n    \"Don't forget to handle edge cases: what if the stack is empty when you need to pop? What should the stack look like at the end?\"\n  ],\n  \"tags\": [\"string\", \"stack\"],\n  \"companies\": [\"Amazon\", \"Google\", \"Facebook\", \"Microsoft\", \"Bloomberg\"],\n  \"leetcodeUrl\": \"https://leetcode.com/problems/valid-parentheses/\",\n  \"createdAt\": \"2024-01-15T10:30:00.000Z\",\n  \"updatedAt\": \"2024-06-20T14:45:00.000Z\",\n  \"metadata\": {\n    \"source\": \"leetcode\",\n    \"sourceId\": \"20\"\n  }\n}\n",
};

/**
 * Get all problem slugs
 */
export function getAllProblemSlugs(): string[] {
  return Object.keys(PROBLEM_DATA);
}

/**
 * Get problem JSON by slug
 */
export function getProblemJson(slug: string): string | null {
  return PROBLEM_DATA[slug] ?? null;
}
