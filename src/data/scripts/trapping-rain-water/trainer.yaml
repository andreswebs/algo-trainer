id: trapping-rain-water
title: Trapping Rain Water
difficulty: hard
tags:
  - array
  - two-pointers
  - dynamic-programming
  - stack
language: typescript
steps:
  - type: intro
    content: |
      # Trapping Rain Water
      
      Welcome to a classic hard problem! üéØ
      
      **The challenge:** Calculate how much rain water can be trapped between elevation bars.
      
      **Example:**
      - Height: [0,1,0,2,1,0,1,3,2,1,2,1]
      - Answer: 6 units of water
      
      **Visualization:**
      ```
             ‚ñà
         ‚ñà   ‚ñà‚ñà ‚ñà
       ‚ñà ‚ñà ‚ñà ‚ñà‚ñà‚ñà‚ñà
       ```
      
      This is a famous interview problem with multiple elegant solutions!

  - type: pre_prompt
    content: |
      Think about what determines water at each position:
      
      **Key insight:** Water at position i = min(max_left, max_right) - height[i]
      - If this is positive, water can be trapped
      - If negative or zero, no water
      
      **Three approaches:**
      
      **1. Brute Force:** For each position, find max left and right - O(n¬≤)
      
      **2. Dynamic Programming:** Pre-compute max left/right arrays - O(n) time, O(n) space
      
      **3. Two Pointers (optimal):** Track max while scanning - O(n) time, O(1) space ‚ú®
      
      **Recommended:** Start with DP approach, then optimize to two pointers if you can!

  - type: hint
    trigger: '!code.includes(''left'') || !code.includes(''right'')'
    content: |
      **Hint:** Think about what limits the water at each position!
      
      Water trapped at position i depends on:
      - Maximum height to its LEFT
      - Maximum height to its RIGHT
      - Water = min(maxLeft, maxRight) - height[i]
      
      **DP approach:**
      1. Compute leftMax array: leftMax[i] = max height from 0 to i
      2. Compute rightMax array: rightMax[i] = max height from i to end
      3. For each i: water += min(leftMax[i], rightMax[i]) - height[i]
      
      This is easier to understand than two pointers!

  - type: hint
    trigger: code.includes('left') && code.includes('right') && code.includes('Max')
    content: |
      Great! You're using the DP approach! üéâ
      
      **Algorithm:**
      ```typescript
      // Compute leftMax
      leftMax[0] = height[0];
      for (let i = 1; i < n; i++) {
        leftMax[i] = Math.max(leftMax[i-1], height[i]);
      }
      
      // Compute rightMax
      rightMax[n-1] = height[n-1];
      for (let i = n-2; i >= 0; i--) {
        rightMax[i] = Math.max(rightMax[i+1], height[i]);
      }
      
      // Calculate water
      for (let i = 0; i < n; i++) {
        water += Math.min(leftMax[i], rightMax[i]) - height[i];
      }
      ```

  - type: on_run
    trigger: '!passed && attempts > 1'
    content: |
      Let me help you debug:
      
      **DP approach checklist:**
      1. ‚úÖ Create leftMax array:
         - leftMax[0] = height[0]
         - leftMax[i] = max(leftMax[i-1], height[i])
      2. ‚úÖ Create rightMax array:
         - rightMax[n-1] = height[n-1]
         - rightMax[i] = max(rightMax[i+1], height[i])
      3. ‚úÖ Calculate water:
         - For each i: min(leftMax[i], rightMax[i]) - height[i]
         - Sum all positive values
      
      **Common mistakes:**
      - Wrong loop direction for rightMax (should go backwards)
      - Forgetting to handle negative water values (shouldn't add negative)
      - Array index out of bounds

  - type: on_run
    trigger: '!passed && attempts > 2 && code.includes(''left'') && code.includes(''right'')'
    content: |
      Still debugging? Let's trace through a small example:
      
      **height = [0, 1, 0, 2, 1, 0, 1, 3]**
      
      ```
      leftMax  = [0, 1, 1, 2, 2, 2, 2, 3]
      rightMax = [3, 3, 3, 3, 3, 3, 3, 3]
      
      Position 0: min(0,3) - 0 = 0
      Position 1: min(1,3) - 1 = 0
      Position 2: min(1,3) - 0 = 1  ‚Üê water!
      Position 3: min(2,3) - 2 = 0
      Position 4: min(2,3) - 1 = 1  ‚Üê water!
      Position 5: min(2,3) - 0 = 2  ‚Üê water!
      Position 6: min(2,3) - 1 = 1  ‚Üê water!
      Position 7: min(3,3) - 3 = 0
      
      Total: 0+0+1+0+1+2+1+0 = 5 units
      ```
      
      Trace through your code with this example!

  - type: on_request
    keywords:
      - hint
      - help
      - stuck
      - two
      - pointer
    content: |
      **Two Pointers approach (O(1) space):**
      
      This is more advanced but elegant:
      
      ```typescript
      function trap(height: number[]): number {
        let left = 0, right = height.length - 1;
        let leftMax = 0, rightMax = 0;
        let water = 0;
        
        while (left < right) {
          if (height[left] < height[right]) {
            if (height[left] >= leftMax) {
              leftMax = height[left];
            } else {
              water += leftMax - height[left];
            }
            left++;
          } else {
            if (height[right] >= rightMax) {
              rightMax = height[right];
            } else {
              water += rightMax - height[right];
            }
            right--;
          }
        }
        
        return water;
      }
      ```
      
      **Key idea:** Move pointer from the side with smaller max height!

  - type: on_request
    keywords:
      - complexity
      - optimization
    content: |
      **Complexity Comparison:**
      
      **Brute Force:**
      - Time: O(n¬≤) - for each position, scan left and right ‚ùå
      - Space: O(1)
      
      **Dynamic Programming:**
      - Time: O(n) - three passes ‚úÖ
      - Space: O(n) - two arrays for leftMax and rightMax
      
      **Two Pointers (optimal):**
      - Time: O(n) - single pass ‚úÖ
      - Space: O(1) - only variables ‚ú®
      
      The two pointers approach is optimal, but DP is easier to understand!
      
      **Both O(n) approaches are acceptable in interviews** - DP is clearer, two pointers shows mastery.

  - type: after_success
    content: |
      üéâ Incredible! You solved Trapping Rain Water!
      
      **What you learned:**
      - Dynamic programming with pre-computation
      - Space-time trade-offs
      - Two-pointer optimization technique
      
      **Complexity:**
      - DP: O(n) time, O(n) space
      - Two pointers: O(n) time, O(1) space ‚ú®
      
      **This pattern appears in:**
      - Container With Most Water
      - Product of Array Except Self
      - Largest Rectangle in Histogram
      
      **Key lesson:** Sometimes O(n) space can be optimized to O(1) with clever pointer techniques!
      
      **Interview tip:** Explain the DP approach first (clearer), then mention two-pointer optimization!
      
      Fantastic work on this hard problem! üöÄ
