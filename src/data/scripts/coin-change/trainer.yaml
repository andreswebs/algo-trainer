id: coin-change
title: Coin Change
difficulty: medium
tags:
  - array
  - dynamic-programming
  - breadth-first-search
language: typescript
steps:
  - type: intro
    content: |
      # Coin Change
      
      Welcome to a classic dynamic programming problem! ðŸŽ¯
      
      **The challenge:** Find the minimum number of coins needed to make a given amount.
      
      **Example:**
      - Coins: [1, 2, 5]
      - Amount: 11
      - Answer: 3 (5 + 5 + 1)
      
      This teaches the "unbounded knapsack" DP pattern - each coin can be used unlimited times!

  - type: pre_prompt
    content: |
      Think about building up from smaller amounts:
      
      **Key insight:** To make amount n, you can use any coin and solve for (n - coin value).
      
      **Dynamic Programming approach:**
      
      1. Create array `dp` where `dp[i]` = minimum coins needed for amount i
      2. Base case: `dp[0] = 0` (zero coins for amount 0)
      3. For each amount from 1 to target:
         - Try each coin
         - Take minimum: `dp[amount] = min(dp[amount], dp[amount - coin] + 1)`
      
      **Formula:** `dp[i] = min(dp[i], dp[i - coin] + 1)` for each coin
      
      **Important:** Initialize dp with Infinity (or amount + 1) except dp[0] = 0

  - type: hint
    trigger: '!code.includes(''dp'') && !code.includes(''memo'')'
    content: |
      **Hint:** This is a dynamic programming problem!
      
      You need to build up solutions for smaller amounts to solve larger amounts.
      
      **Key steps:**
      1. Create a dp array: `const dp = new Array(amount + 1).fill(Infinity);`
      2. Base case: `dp[0] = 0;`
      3. For each amount, try each coin and take the minimum
      
      Think bottom-up: solve for amount 1, then 2, then 3, ... up to target!

  - type: hint
    trigger: code.includes('dp') && !code.includes('Infinity')
    content: |
      **Important:** Initialize dp values carefully!
      
      ```typescript
      const dp = new Array(amount + 1).fill(Infinity);
      dp[0] = 0;  // Base case: 0 coins for amount 0
      ```
      
      **Why Infinity?** 
      - Represents "impossible" or "not yet computed"
      - Makes taking minimum work correctly
      - At the end, if dp[amount] is still Infinity, return -1

  - type: on_run
    trigger: '!passed && code.includes(''dp'')'
    content: |
      You're using DP - great! Let me help debug:
      
      **Algorithm checklist:**
      1. âœ… Initialize: `dp = Array(amount + 1).fill(Infinity); dp[0] = 0;`
      2. âœ… For each amount from 1 to target:
         ```
         for (let i = 1; i <= amount; i++) {
           for (const coin of coins) {
             if (i >= coin) {
               dp[i] = Math.min(dp[i], dp[i - coin] + 1);
             }
           }
         }
         ```
      3. âœ… Return: `dp[amount] === Infinity ? -1 : dp[amount];`
      
      **Common mistakes:**
      - Wrong loop order (coins loop should be inside amount loop)
      - Forgetting to check `i >= coin` before accessing `dp[i - coin]`
      - Not returning -1 when amount is impossible

  - type: on_run
    trigger: '!passed && attempts > 2'
    content: |
      Let's trace through an example:
      
      **coins = [1, 2, 5], amount = 11**
      
      ```
      dp[0] = 0
      dp[1] = 1 (use coin 1)
      dp[2] = 1 (use coin 2)
      dp[3] = 2 (use coin 2 + coin 1)
      dp[4] = 2 (use coin 2 + coin 2)
      dp[5] = 1 (use coin 5)
      dp[6] = 2 (use coin 5 + coin 1)
      ...
      dp[11] = 3 (use coin 5 + coin 5 + coin 1)
      ```
      
      **For each amount, try every coin and take the minimum!**
      
      Trace through your code with this example to find the bug.

  - type: on_request
    keywords:
      - hint
      - help
      - stuck
    content: |
      **Complete DP solution:**
      
      ```typescript
      function coinChange(coins: number[], amount: number): number {
        // Initialize DP array
        const dp = new Array(amount + 1).fill(Infinity);
        dp[0] = 0;  // Base case
        
        // For each amount
        for (let i = 1; i <= amount; i++) {
          // Try each coin
          for (const coin of coins) {
            if (i >= coin) {
              // Can use this coin
              dp[i] = Math.min(dp[i], dp[i - coin] + 1);
            }
          }
        }
        
        // Return result
        return dp[amount] === Infinity ? -1 : dp[amount];
      }
      ```
      
      **Why it works:** For each amount, we try every coin and take the best option!

  - type: on_request
    keywords:
      - complexity
      - optimization
    content: |
      **Complexity Analysis:**
      
      **Bottom-up DP (optimal):**
      - Time: O(amount Ã— coins.length)
        - For each amount: O(amount)
        - Try each coin: O(coins.length)
      - Space: O(amount) for the dp array
      
      **BFS approach (alternative):**
      - Time: O(amount Ã— coins.length) similar
      - Space: O(amount) for the queue
      
      **This is optimal!** You must check each amount with each coin.
      
      **Note:** Some people use BFS (treating it as shortest path), but DP is more straightforward!

  - type: after_success
    content: |
      ðŸŽ‰ Fantastic! You solved Coin Change!
      
      **What you learned:**
      - Bottom-up dynamic programming
      - Unbounded knapsack pattern (unlimited use of items)
      - Building solutions from subproblems
      
      **Complexity:** O(amount Ã— coins) time, O(amount) space âœ¨
      
      **This pattern appears in:**
      - Coin Change II (count combinations)
      - Perfect Squares
      - Minimum Cost for Tickets
      - Unbounded Knapsack problems
      
      **Key lesson:** DP builds optimal solutions by combining optimal subproblem solutions!
      
      Excellent work! ðŸš€
