id: climbing-stairs
title: Climbing Stairs
difficulty: easy
tags:
  - math
  - dynamic-programming
  - memoization
language: typescript
steps:
  - type: intro
    content: |
      # Climbing Stairs
      
      Welcome to your first dynamic programming problem! ðŸŽ¯
      
      **The challenge:** Count how many ways to climb n stairs if you can climb 1 or 2 steps at a time.
      
      **Example:** n=3 has 3 ways:
      - 1 + 1 + 1
      - 1 + 2
      - 2 + 1
      
      This problem is deceptively simple but teaches core DP concepts!

  - type: pre_prompt
    content: |
      Let's think about this problem step by step:
      
      **Key insight:** To reach stair n, you can only come from:
      - Stair (n-1) by taking 1 step, OR
      - Stair (n-2) by taking 2 steps
      
      **Therefore:** ways(n) = ways(n-1) + ways(n-2)
      
      **Sound familiar?** This is the Fibonacci sequence! ðŸŽ‰
      
      **Three approaches to consider:**
      1. **Recursive** (simple but slow - exponential time)
      2. **Memoization** (cache recursive results - O(n) time)
      3. **Iterative DP** (bottom-up - O(n) time, O(1) space) âœ¨
      
      Start with what makes sense to you. You can always optimize later!

  - type: hint
    trigger: code.includes('function') && code.includes('climbStairs') && code.includes('climbStairs')
    content: |
      I see you're using recursion! That's a great starting point to understand the problem.
      
      **However:** Plain recursion recalculates the same values many times (exponential time).
      
      **To optimize:**
      1. **Add memoization** - cache results in a Map or array
      2. **Or use iterative DP** - build up from base cases
      
      For small n, recursion works. For larger n, you'll need optimization!

  - type: hint
    trigger: '!code.includes(''climbStairs'') || !code.includes(''climbStairs'')'
    content: |
      **Think about the pattern:**
      
      - n=1: 1 way (just 1 step)
      - n=2: 2 ways (1+1 or 2)
      - n=3: 3 ways (ways to reach n=1 + ways to reach n=2)
      - n=4: 5 ways (ways to reach n=2 + ways to reach n=3)
      
      **See the pattern?** Each value is the sum of the previous two!
      
      **Iterative approach:**
      ```
      Start with base cases: dp[1]=1, dp[2]=2
      For i from 3 to n:
        dp[i] = dp[i-1] + dp[i-2]
      Return dp[n]
      ```
      
      **Space optimization:** You only need the last 2 values, not the whole array!

  - type: on_run
    trigger: '!passed && attempts > 1'
    content: |
      Let me help you debug:
      
      **Check these:**
      1. **Base cases:** 
         - n=1 should return 1
         - n=2 should return 2
      2. **Recurrence relation:**
         - ways(n) = ways(n-1) + ways(n-2)
      3. **Loop bounds:** Are you starting from the right index?
      
      **Common mistakes:**
      - Off-by-one errors in loop
      - Wrong base cases
      - Not handling edge cases (n=0, n=1)
      
      Try tracing through n=3 manually to verify your logic!

  - type: on_run
    trigger: stderr.includes('stack') || stderr.includes('Maximum call stack')
    content: |
      **Stack overflow!** Your recursion is too deep.
      
      This happens with plain recursion because it recalculates the same values repeatedly.
      
      **Solutions:**
      1. **Add memoization:** Store calculated results to avoid recalculation
      2. **Use iteration:** Build bottom-up instead of top-down
      
      The iterative approach is simpler and more efficient for this problem!

  - type: on_request
    keywords:
      - hint
      - help
      - fibonacci
      - dp
    content: |
      **Dynamic Programming Approach:**
      
      This IS the Fibonacci sequence!
      
      **Iterative solution (optimal):**
      ```typescript
      function climbStairs(n: number): number {
        if (n <= 2) return n;
        
        let prev2 = 1;  // n=1
        let prev1 = 2;  // n=2
        
        for (let i = 3; i <= n; i++) {
          const current = prev1 + prev2;
          prev2 = prev1;
          prev1 = current;
        }
        
        return prev1;
      }
      ```
      
      **Why this works:** We only need the last 2 values to compute the next one!

  - type: on_request
    keywords:
      - complexity
      - optimization
    content: |
      **Complexity Analysis:**
      
      **Approach 1 - Plain Recursion:**
      - Time: O(2â¿) - exponential! âŒ
      - Space: O(n) - call stack
      
      **Approach 2 - Memoization:**
      - Time: O(n) - each value computed once âœ…
      - Space: O(n) - cache + call stack
      
      **Approach 3 - Iterative (optimal):**
      - Time: O(n) - single loop âœ…
      - Space: O(1) - only store 2 variables! âœ¨
      
      The iterative approach with O(1) space is optimal for this problem!

  - type: after_success
    content: |
      ðŸŽ‰ Excellent! You solved Climbing Stairs!
      
      **What you learned:**
      - Dynamic programming fundamentals
      - Identifying recurrence relations
      - The Fibonacci sequence pattern
      - Space optimization techniques
      
      **Complexity:**
      - Optimal: O(n) time, O(1) space âœ¨
      - With array: O(n) time, O(n) space
      
      **This pattern appears in:**
      - House Robber
      - Decode Ways  
      - Min Cost Climbing Stairs
      - Fibonacci Number
      
      **Key lesson:** Many DP problems can be space-optimized by keeping only the values you need!
      
      Great job! ðŸš€
