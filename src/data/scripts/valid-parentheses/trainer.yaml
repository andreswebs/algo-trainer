id: valid-parentheses
title: Valid Parentheses
difficulty: easy
tags:
  - string
  - stack
language: typescript
steps:
  - type: intro
    content: |
      # Valid Parentheses
      
      Welcome to a classic stack problem! ðŸŽ¯
      
      **The challenge:** Determine if a string of brackets is valid.
      - Every opening bracket must have a matching closing bracket
      - Brackets must close in the correct order
      
      **Examples:**
      - "()" âœ… valid
      - "()[]{}" âœ… valid  
      - "(]" âŒ invalid (wrong closing bracket)
      - "([)]" âŒ invalid (wrong order)
      
      This problem teaches the fundamental LIFO (Last In, First Out) pattern!

  - type: pre_prompt
    content: |
      Think about how you match brackets:
      
      **Key observation:** The LAST opened bracket must close FIRST!
      
      **This is a Stack problem!** ðŸ“š
      - When you see an opening bracket: push it onto a stack
      - When you see a closing bracket: check if it matches the top of the stack
      - If it matches: pop from stack and continue
      - If it doesn't match: invalid!
      - At the end: stack should be empty (all brackets matched)
      
      **Data structure hint:** Use an array as a stack with push() and pop()
      
      Try to implement this approach - it's elegant and O(n) time!

  - type: hint
    trigger: '!code.includes(''push'') && !code.includes(''pop'')'
    content: |
      **Hint:** This is a classic stack problem!
      
      Think about it: when you see a closing bracket, which opening bracket should it match?
      The MOST RECENT one - that's LIFO (Last In, First Out) - that's a Stack!
      
      **Algorithm:**
      - Use an array as a stack
      - Push opening brackets: (, [, {
      - When you see a closing bracket, pop and check if it matches
      
      Try using push() and pop() methods!

  - type: hint
    trigger: code.includes('push') && code.includes('pop')
    content: |
      Great! You're using a stack approach! ðŸŽ‰
      
      **Common edge cases to handle:**
      1. What if you see a closing bracket but the stack is empty?
      2. What if there are unmatched opening brackets at the end?
      3. Are you checking that closing brackets match the right type?
      
      Make sure your solution handles all these cases!

  - type: on_run
    trigger: '!passed && attempts > 1'
    content: |
      Let me help you debug:
      
      **Stack algorithm checklist:**
      1. âœ… Create an empty stack (array)
      2. âœ… For each character:
         - If opening bracket: push to stack
         - If closing bracket:
           - Check if stack is empty â†’ return false
           - Pop from stack and verify it matches â†’ if not, return false
      3. âœ… After loop: return stack.length === 0
      
      **Matching pairs:**
      - ')' matches '('
      - ']' matches '['
      - '}' matches '{'
      
      **Common mistakes:**
      - Forgetting to check if stack is empty before popping
      - Not checking if brackets match
      - Not checking if stack is empty at the end

  - type: on_run
    trigger: stderr.includes('undefined') || stderr.includes('null')
    content: |
      You're trying to access something that doesn't exist!
      
      **Common cause:** Popping from an empty stack
      
      **Fix:** Before calling pop(), check if the stack has elements:
      ```typescript
      if (stack.length === 0) {
        return false; // Can't match a closing bracket
      }
      ```

  - type: on_request
    keywords:
      - hint
      - help
      - stuck
      - approach
    content: |
      **The Stack Pattern for Matching:**
      
      ```
      stack = []
      
      for each character c:
        if c is opening bracket:
          push c to stack
        else: // c is closing bracket
          if stack is empty:
            return false  // No matching opening
          popped = stack.pop()
          if popped doesn't match c:
            return false  // Wrong type of bracket
      
      return stack.length === 0  // All matched?
      ```
      
      **Tip:** Use a Map or object to store matching pairs:
      ```typescript
      const pairs = { ')': '(', ']': '[', '}': '{' };
      ```

  - type: on_request
    keywords:
      - complexity
      - optimization
    content: |
      **Complexity Analysis:**
      
      **Time:** O(n) where n is the string length
      - Single pass through the string
      - Each push/pop is O(1)
      
      **Space:** O(n) worst case
      - If all characters are opening brackets: "((((("
      - Stack stores all of them
      
      This is already optimal! You can't do better than O(n) since you must check every character.

  - type: after_success
    content: |
      ðŸŽ‰ Perfect! You solved Valid Parentheses!
      
      **What you learned:**
      - Stack data structure and LIFO principle
      - Using a stack for matching/pairing problems
      - Handling edge cases (empty stack, unmatched brackets)
      
      **Complexity:** O(n) time, O(n) space - optimal!
      
      **This pattern appears in:**
      - Expression evaluation
      - HTML/XML tag matching
      - Undo/redo functionality
      - Browser back button
      
      **Similar problems:** Remove Adjacent Duplicates, Decode String, Basic Calculator
      
      Excellent work! ðŸš€
